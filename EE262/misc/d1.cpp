
#include <iostream>
#include "simvd.h"
using namespace std;

int main(void){

  simvd x1;

  cout<<"cap: "<<x1.get_capacity()<<endl;
  cout<<x1.get_size()<<endl;
  
  x1.append(87);
  cout<<x1.get_size()<<endl;

  for(int i=0; i<12; i++){
    x1.append(i*3);
  }

  cout<<"cap: "<<x1.get_capacity()<<endl;
  cout<<"size: "<<x1.get_size()<<endl;
  cout<<"x1: ";
  x1.print();

  cout<<x1.at(1)<<endl;

  x1.set(56.5, 1);
  x1.print();

  simvd x2(8);
  cout<<x2.get_capacity()<<endl;

  simvd x3(x1); //if this is not defined, this can still work by an implicit constructor, but might not be the correct way
//implicit constructor (this is an auto generated constructer at complie time)
//default (zero arguments)

  x3.print();

  simvd x4={1.4, 5.2, 6.2};
  x4.print();



  
  simvd x5;
  x5 = x3; //this is another example of an implicit function that is generated by compiler, (implict copy assignment was made)
  //pointers are now pointing at each other through implicit function and one deconstructor will delete data of two objects at the same time and this is dangerous, runtime error should exist

  //need to overload user defined the = operator 

  x5 = x3 = x1; //this is valid if everything were ints  (go from right to left, to add)
  //we have a problem because we use a void return type, do we need to overload again but return simvd?


  x3.print();
  x5.print();
  


  return 0;
}